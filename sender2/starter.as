package {	import flash.display.Sprite;	import flash.text.TextFormat;	import flash.text.Font;	import flash.events.*;	import flash.utils.*;	import flash.media.*;	import flash.net.*;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.geom.Rectangle;	import flash.events.TimerEvent;	import flash.utils.Timer;	import classi.main.Rett;	import classi.main.Txt;	import classi.main.TxtStyle;	import classi.comp.SliderCh;	public class starter extends Sprite {		private var render,ts;		public var webcam;		public var btn:Sprite;		public var btnStop:Sprite;		public var btnAlgShape:Sprite;		public var btnAlgLum:Sprite;		public var myslide:Sprite;		public var w=400;		public var h=300;		public var shot:Sprite;		public var bd;		public var bm;		public var testaccio;		public var mycam:Camera;		public var delay:Number=1000;		public var myTimer:Timer;		public var serverIp;		public var serverPort;		public var socket;		public var Max=0;		public var Min=255;		public var luminosity;		//public var algorithmMode="shape";		public var algorithmMode="intensity";				public function starter() {			//this.serverIp="localhost";			this.serverIp="192.168.1.37";			this.serverPort=18000;			TxtStyle.startTs();			this.mycam=Camera.getCamera(2);			this.mycam.setMotionLevel(10,1000);			this.mycam.setQuality(100,1);			this.mycam.setMode(320,240,12,true);			this.webcam=new Video;			this.webcam.attachCamera(mycam);			this.webcam.x=10;			this.webcam.y=10;			this.addChild(webcam);						this.btn=new Button;			this.btn.avvia({fnz:processStart,txt:"START",alt:"print frame"});			this.btn.scaleX=this.btn.scaleY=2;			this.btn.x=20;			this.btn.y=260;			this.addChild(this.btn);						this.btnStop=new Button;			this.btnStop.avvia({fnz:processStop,txt:"STOP",alt:"print frame"});			this.btnStop.scaleX=this.btnStop.scaleY=2;			this.btnStop.x=150;			this.btnStop.y=260;			this.addChild(this.btnStop);						this.btnAlgLum=new Button;			this.btnAlgLum.avvia({fnz:setLumAlg,txt:"LUM",alt:"print frame"});			this.btnAlgLum.scaleX=this.btnAlgLum.scaleY=2;			this.btnAlgLum.x=20;			this.btnAlgLum.y=290;			this.addChild(this.btnAlgLum);						this.btnAlgShape=new Button;			this.btnAlgShape.avvia({fnz:setShapeAlg,txt:"SHAPE",alt:"print frame"});			this.btnAlgShape.scaleX=this.btnAlgShape.scaleY=2;			this.btnAlgShape.x=150;			this.btnAlgShape.y=290;			this.addChild(this.btnAlgShape);						this.myslide=new SliderCh(300,270,20,70,setLuminosity,"Luminosity");			this.luminosity=100			this.addChild(this.myslide);						this.bd=new BitmapData(this.mycam.width,this.webcam.height,false,0xFFFFFFFF);			this.socket = new XMLSocket(); // nouvelle instance de XMLSocket()			this.socket.connect(this.serverIp, this.serverPort); // connexion au serveur sur le port 18000					this.myTimer=new Timer(50,0);			this.myTimer.addEventListener("timer",timerHandler);		}		function setLumAlg(n){			this.algorithmMode="intensity";		}				function setShapeAlg(n){			this.algorithmMode="shape"		}				function setLuminosity(n){			this.luminosity=Math.round(n);			//trace(Math.round(n));				}				function processStop(t){			this.myTimer.stop();		}				function processStart(t){			trace(this.algorithmMode);			if(this.algorithmMode=="shape"){				this.processShapeImage("b");			}else{				this.processIntensityImage("b");			}		}				public function timerHandler(event:TimerEvent):void {			this.myTimer.stop();			//this.processDisplayImage("bella");			if(algorithmMode=="shape"){				this.processShapeImage("b");			}else{				this.processIntensityImage("b");			}		}				/* INTENSITY */				public function processIntensityImage(t) {			this.bm=new Bitmap(this.bd);			this.addChild(this.bm);			this.bd.draw(this.webcam);			var xMax:int=this.bd.width;			var yMax:int=this.bd.height;			var c:uint;			var cmed:int;			var mc:int;			var res:int=4;			var bounds:Rectangle;			var debugStr:String;			var localMax=this.Max;			var localMin=this.Min;			var riga=0;			var palette:String = "@#$%8BMW*mwqpdbkhaoQ0OZXYUJCLtfjzxnuvcr[]{}1()|/?Il!i_~-;,.    ";			for (var i=0; i < yMax; i+= res) {				debugStr="";				for (var j=0; j < xMax; j+= res) {					cmed=0;					bounds=new Rectangle(j,i,res,res);					c=this.bd.getPixel(j,i);					cmed+=Math.floor(0.3 * (c >> 16 & 0xff) + 0.59 * (c >> 8 & 0xff) + 0.11 * (c & 0xff));					if(cmed>localMax) localMax=cmed;					if(cmed<localMin) localMin=cmed;									if (cmed < this.Min){						cmed = 0xFF;					}else if (cmed > this.Max){						cmed = 0x00;					}else{						cmed = Math.floor(0xFF * ((cmed - this.Min) / (this.Max - this.Min)));					}					debugStr+=palette.charAt(Math.floor(cmed / 4));					this.bd.fillRect(bounds,(255 << 24 | cmed << 16 | cmed << 8 | cmed));				}				this.socket.send("<message deep=\""+riga+"\" y=\""+(i*1)+"\">"+debugStr+"</message>");				riga++;			}			this.Max=localMax;			this.Min=localMin;			this.bm.x=10;			this.bm.y=350;			this.bm.visible=true;			this.myTimer.start();		}			/*		SHAPE */		public function processShapeImage(t) {			this.bm=new Bitmap(this.bd);			this.addChild(this.bm);			this.bd.draw(this.webcam);			var bianco:uint=255 << 24 | 255 << 16 | 255 << 8 | 255;			var nero:uint=0 << 24 | 0 << 16 | 0 << 8 | 0;			var xMax:int=this.bd.width;			var yMax:int=this.bd.height;			var c:uint;			var cmed:int;			var mc:int;			var res:int=4;			var subres=2;			var quota=this.luminosity;			var bounds:Rectangle;			var debugStr:String;			var segni:Array=[" ",".",",","_","'",")","/","J","`","\\","(","L","~","7","P","8"];			var riga=0;			var localMax=this.Max;			var localMin=this.Min;			//var current_pixel:ByteArray;			for (var i=0; i < yMax; i+= res) {				debugStr="";				for (var j=0; j < xMax; j+= res) {					pos=0;					mc=0;					bounds=new Rectangle(j,i,subres,subres);					c=this.bd.getPixel(j,i);					cmed=Math.floor(0.3 * (c >> 16 & 0xff) + 0.59 * (c >> 8 & 0xff) + 0.11 * (c & 0xff));					if(cmed>localMax) localMax=cmed;					if(cmed<localMin) localMin=cmed;					if (cmed < this.Min){						cmed = 0xFF;					}else if (cmed > this.Max){						cmed = 0x00;					}else{						cmed = Math.floor(0xFF * ((cmed - this.Min) / (this.Max - this.Min)));					}					this.bd.fillRect(bounds,(255 << 24 | cmed << 16 | cmed << 8 | cmed));										mc+=cmed;					if (cmed < quota) {						pos+= 8;						this.bd.fillRect(bounds,nero);					} else {						this.bd.fillRect(bounds,bianco);					}					bounds=new Rectangle(j + subres,i,subres,subres);					c=this.bd.getPixel(j + subres,i);					cmed=Math.floor(0.3 * (c >> 16 & 0xff) + 0.59 * (c >> 8 & 0xff) + 0.11 * (c & 0xff));					if(cmed>localMax) localMax=cmed;					if(cmed<localMin) localMin=cmed;					if (cmed < this.Min){						cmed = 0xFF;					}else if (cmed > this.Max){						cmed = 0x00;					}else{						cmed = Math.floor(0xFF * ((cmed - this.Min) / (this.Max - this.Min)));					}					this.bd.fillRect(bounds,(255 << 24 | cmed << 16 | cmed << 8 | cmed));										mc+=cmed;					if (cmed < quota) {						pos+= 4;						this.bd.fillRect(bounds,nero);					} else {						this.bd.fillRect(bounds,bianco);					}					bounds=new Rectangle(j,i + subres,subres,subres);					c=this.bd.getPixel(j,i + subres);					cmed=Math.floor(0.3 * (c >> 16 & 0xff) + 0.59 * (c >> 8 & 0xff) + 0.11 * (c & 0xff));					if(cmed>localMax) localMax=cmed;					if(cmed<localMin) localMin=cmed;					if (cmed < this.Min){						cmed = 0xFF;					}else if (cmed > this.Max){						cmed = 0x00;					}else{						cmed = Math.floor(0xFF * ((cmed - this.Min) / (this.Max - this.Min)));					}					this.bd.fillRect(bounds,(255 << 24 | cmed << 16 | cmed << 8 | cmed));										mc+=cmed;					if (cmed < quota) {						pos+= 2;						this.bd.fillRect(bounds,nero);					} else {						this.bd.fillRect(bounds,bianco);					}					bounds=new Rectangle(j + subres,i + subres,subres,subres);					c=this.bd.getPixel(j + subres,i + subres);					cmed=Math.floor(0.3 * (c >> 16 & 0xff) + 0.59 * (c >> 8 & 0xff) + 0.11 * (c & 0xff));					if(cmed>localMax) localMax=cmed;					if(cmed<localMin) localMin=cmed;					if (cmed < this.Min){						cmed = 0xFF;					}else if (cmed > this.Max){						cmed = 0x00;					}else{						cmed = Math.floor(0xFF * ((cmed - this.Min) / (this.Max - this.Min)));					}					this.bd.fillRect(bounds,(255 << 24 | cmed << 16 | cmed << 8 | cmed));										mc+=cmed;					if (cmed < quota) {						pos+= 1;						this.bd.fillRect(bounds,nero);					} else {						this.bd.fillRect(bounds,bianco);					}										debugStr=debugStr + segni[pos];				}				this.socket.send("<message deep=\""+riga+"\" y=\""+(i*1)+"\">"+debugStr+"</message>");				riga++;			}			this.Max=localMax;			this.Min=localMin;			this.bm.x=10;			this.bm.y=350;			this.bm.visible=true;			this.myTimer.start();		}			}}